#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Tue Jul 31 10:29:47 2018

@author: juliaorenstein
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy.constants
import math


## initialization stuff
samplesize = 2000000
window = 100000
samplingfreq = 10000000.
timestep = 1/samplingfreq
datalocation = '/Users/juliaorenstein/GitHub/BrownianMotionExperiment/Data/subtracted/2018_06_06_1_sub.txt'
position = np.array(list(open(datalocation, 'r')), dtype = float)[64:-64]

# known constants 
T = 298
k = scipy.constants.k

step = (np.arange(samplesize)) # time steps
time = step*timestep # time values in seconds


## calculate MSD
sum_disp_sq = []
for i in range(samplesize):
    disp_sq = (position[i] - position[0])**2
    if i == 0:
        sum_disp_sq.append(0)
    else:
        sum_disp_sq.append(sum_disp_sq[-1]+disp_sq)

msd_lhs = sum_disp_sq/step #MSD 
msd_lhs[0] = 0

plt.plot(time[:window],msd_lhs[:window])
plt.show()
# plt.plot(time,position[:window])


## Calculate normalized position autocorrelation function
pacf_lhs = []
for i in position:
    pacf = i * position[0] 
    pacf_lhs.append(pacf)
    
    
    #try not to use momentum relaxation time -- Raizen
def pacf_rhs(t, M, omega_0):
    #M = mass of sphere
    #omega_0 = natural frequency without damping
    
    R =  6.1 * 10**(-6) #radius of sphere
    visc = 1. #viscosity of fluid
    gamma = 6 * math.pi * visc *  R #Stoke's friction coefficient
    tau = M / gamma #momentum relaxation time
    
    roe = 1 / tau #damping coefficient
    omega_1 = math.sqrt(omega_0**2 - roe**2/4) #cyclic frequency of damped oscillator
    
    # equation
    mean_squared = k * T / (M * omega_0**2)
    exp = (np.exp(-t/(2 * tau)))
    term_one = (np.cos(omega_1 * t))
    term_two = (np.cos(omega_1 * t)/(2 * omega_1 * tau))
    
    return mean_squared * exp * (term_one + term_two)


print scipy.optimize.curve_fit(pacf_rhs, time, pacf_lhs)
plt.plot(time[:window], pacf_lhs[:window])
plt.plot(time[:window], pacf_rhs(time, 1, 1)[:window])

'''def msd_rhs(t, bigo, mrt)
    return constant * (1 - npacf(t, bigo, mrt))


def npacf(t, bigo, mrt)
    return exp(-t/(2*mrt))*()

print scipy.optimize.curve_fit(rhs(t, bigo, mrt), time, msd)
'''

'''
def position(pos,resolution, sampling):   
    timeStep = int(np.ceil(resolution*sampling))
    
    velocity = []
    for i in np.arange(timeStep,len(pos)-(timeStep),1):      
        firstHalf = np.average(pos[i-timeStep:i])
        secondHalf = np.average(pos[i:i+timeStep])
        
        velocityVal = (secondHalf - firstHalf)/resolution
        velocity.append(velocityVal)
    return velocity

'''